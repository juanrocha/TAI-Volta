devtools::install_github("njtierney/naniar")
library(ergm.count)
help(ergm.count)
help(ergm)
vignette('ergm-term-crossRef')
search.ergmTerms(valued)
search.ergmTerms("valued")
help(package = "ergm.count")
library('spml')
install.packages('spml')
install.packages('spml', source = T)
install.packages('splm', source = T)
library('splm')
data("Produc", package = "Ecdat")
install.packages("Ecdat")
data("Produc", package = "Ecdat")
data("usaww")
usaww
library("spdep")
usalw <- mat2listw(usaww)
# transform weights matrix to list#
usalw
class(usalw)
names(usalw)
usalw$style
usalw$neighbours
usalw$weights
fm <- log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp
fm <- log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp#
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, model = "random", lag = TRUE, spatial.error = "b")
summary(mod)
spml(formula = fm, data = Produc, index = NULL,#
+    listw = usalw, model = "random", lag = FALSE, spatial.error = "kkp")
spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, model = "random", lag = FALSE, spatial.error = "kkp")
mod <- spml(formula = fm, data = Produc, index = NULL,
listw = usalw, model = "random", lag = FALSE, spatial.error = "kkp")
summary(mod)
help(spml)
mod$arcoef
mod$errcomp
## fixed effects models#
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, lag = TRUE, spatial.error = "b", model = "within",#
    effect = "individual", method = "eigen", na.action = na.fail,#
    quiet = TRUE, zero.policy = NULL, interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
# fixed effects models#
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, lag = TRUE, spatial.error = "b", model = "within",#
    effect = "individual", method = "eigen", na.action = na.fail,#
    quiet = TRUE, zero.policy = NULL, #
    tol.solve = 1e-10, control = list(), legacy = FALSE)
summary(mod)
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, lag = TRUE, spatial.error = "b", model = "within",#
    effect = "individual", method = "eigen", na.action = na.fail,#
    quiet = TRUE, zero.policy = NULL, interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
mod <- spml(formula = fm, data = Produc, index = NULL, listw = usalw,
model = "within", effect = "individual", method = "eigen",
mod <- spml(formula = fm, data = Produc, index = NULL, listw = usalw,#
    model = "within", effect = "individual", method = "eigen",#
    na.action = na.fail, quiet = TRUE, zero.policy = NULL, interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
mod <- spml(formula = fm, data = Produc, index = NULL, listw = usalw,#
    model = "within", effect = "individual", method = "eigen",#
    na.action = na.fail, quiet = TRUE, zero.policy = NULL, #interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
summary(mod)
eff <- effects(mod)
dff
eff
dim(Produc)
Produc
dim(usalw)
dim(usalww)
dim(usaww)
mod <- spml(formula = fm, data = Produc, index = NULL, listw = usalw,#
    model = "within", effect = "time", method = "eigen",#
    na.action = na.fail, quiet = TRUE, zero.policy = NULL, #interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
summary(mod)
effects(mod)
##generated panel data for yield#
set.seed(97531)#
yield.normal <- as.data.frame(matrix(rnorm(2387*1, mean=1.92, sd=0.5), ncol=1))#
colnames(yield.normal) = "yield"#
yield.normal$panelid = with(yield.normal, seq(1:77))#
yield.normal$timeid = with(yield.normal, seq(1:31))#
yield.normal$county = with(yield.normal, as.factor(seq(1:77)))#
yield.normal$countyname = paste0("county",yield.normal$county)#
yield.normal$trnd = with(yield.normal, seq(1:31))#
#
#generate coordinates of the 77 Oklahoma counties#
latitude.county = sample(36.83013180:33.90212700, size = 77, replace = T)#
longitude.county = sample(-94.81059550:-102.62162110, size = 77, replace = T)#
lat.long.data = cbind2(longitude.county,latitude.county)#
colnames(lat.long.data)=c("lon","lat")#
#Create spatial weight matrix#
distNeighbr = spdep::dnearneigh(lat.long.data, d1=0, d2=5)#
wtmat1 = spdep::nb2listw(distNeighbr, style='W')
ls()
yield.normal
head(yield.normal)
wtmat1
test1 <-  bsktest(x=fn, data = Produc, listw = mat2listw(usaww), test = "LM1")
library('spml')#
library("spdep")#
#
# data for the exercise#
data("Produc", package = "Ecdat")#
data("usaww")#
#
# transform weights matrix to list#
usalw <- mat2listw(usaww)#
#
## model with same spatial lag and spatial error weigths.#
fm <- log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp#
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, model = "random", lag = TRUE, spatial.error = "b")#
#
summary(mod)
library('spml')
library("spdep")
library('splm')
library("spdep")
data("Produc", package = "Ecdat")#
data("usaww")
usalw <- mat2listw(usaww)
fm <- log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp#
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, model = "random", lag = TRUE, spatial.error = "b")#
#
summary(mod)
test1 <-  bsktest(x = fn, data = Produc, listw = mat2listw(usaww), test = "LM1")
test1 <-  bsktest(x = fm, data = Produc, listw = mat2listw(usaww), test = "LM1")
test2
test1
test2 <-  bsktest(x = fm, data = Produc, listw = mat2listw(usaww), test = "LM2")
test2
test3 <-  bsktest(x = fm, data = Produc, listw = mat2listw(usaww), test = "CLMlambda")
test3
test1 <- sphtest( x = fm, data = Produc, listw = mat2listw(usaww), spatial.model = "error", method = "GM")
test1
coeftest(modÂ§)
coeftest(mod1)
library('lmtest')
coeftest(mod1)
coeftest(mod)
library('car')
linearHypothesis(mod, "log(pcap) = log(pc)")
?linearHypothesis
linearHypothesis(mod, "log(pcap) = log(pc)", test = "F")
##generated panel data for yield#
set.seed(97531)#
yield.normal <- as.data.frame(matrix(rnorm(2387*1, mean=1.92, sd=0.5), ncol=1))#
colnames(yield.normal) = "yield"#
yield.normal$panelid = with(yield.normal, seq(1:77))#
yield.normal$timeid = with(yield.normal, seq(1:31))#
yield.normal$county = with(yield.normal, as.factor(seq(1:77)))#
yield.normal$countyname = paste0("county",yield.normal$county)#
yield.normal$trnd = with(yield.normal, seq(1:31))#
#
#generate coordinates of the 77 Oklahoma counties#
latitude.county = sample(36.83013180:33.90212700, size = 77, replace = T)#
longitude.county = sample(-94.81059550:-102.62162110, size = 77, replace = T)#
lat.long.data = cbind2(longitude.county,latitude.county)#
colnames(lat.long.data)=c("lon","lat")#
#Create spatial weight matrix#
distNeighbr = spdep::dnearneigh(lat.long.data, d1=0, d2=5)#
wtmat1 = spdep::nb2listw(distNeighbr, style='W')#
#
#E
yield.normal
head(yield.normal, 10)
#Estimate the spatial fixed-effects model#
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("timeid", "panelid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
yield.normal <- as_tibble(yield.normal)
library(tidyverse)
yield.normal <- as_tibble(yield.normal)
yield.normal
yield.normal <- as.data.frame(matrix(rnorm(2387*1, mean=1.92, sd=0.5), ncol=1))#
colnames(yield.normal) = "yield"#
yield.normal$panelid = with(yield.normal, seq(1:77))#
yield.normal$timeid = with(yield.normal, seq(1:31))#
yield.normal$county = with(yield.normal, as.factor(seq(1:7)))#
yield.normal$countyname = paste0("county",yield.normal$county)#
yield.normal$trnd = with(yield.normal, seq(1:31))
yield.normal <- as_tibble(yield.normal)
yield.normal
yield.normal <- yield.normal %>%#
    arrange(county, panelid, timeid)
yield.normal
#generate coordinates of the 77 Oklahoma counties#
latitude.county = sample(36.83013180:33.90212700, size = 77, replace = T)#
longitude.county = sample(-94.81059550:-102.62162110, size = 77, replace = T)#
lat.long.data = cbind2(longitude.county,latitude.county)#
colnames(lat.long.data)=c("lon","lat")#
#Create spatial weight matrix#
distNeighbr = spdep::dnearneigh(lat.long.data, d1=0, d2=5)#
wtmat1 = spdep::nb2listw(distNeighbr, style='W')
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("timeid", "panelid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
set.seed(97531)#
yield.normal <- as.data.frame(matrix(rnorm(2387*1, mean=1.92, sd=0.5), ncol=1))#
colnames(yield.normal) = "yield"#
yield.normal$panelid = with(yield.normal, seq(1:77))#
yield.normal$timeid = with(yield.normal, seq(1:31))#
yield.normal$county = with(yield.normal, as.factor(seq(1:77)))#
yield.normal$countyname = paste0("county",yield.normal$county)#
yield.normal$trnd = with(yield.normal, seq(1:31))#
#
yield.normal <- as_tibble(yield.normal)#
#
yield.normal <- yield.normal %>%#
    arrange(county, panelid, timeid)
#generate coordinates of the 77 Oklahoma counties#
latitude.county = sample(36.83013180:33.90212700, size = 77, replace = T)#
longitude.county = sample(-94.81059550:-102.62162110, size = 77, replace = T)#
lat.long.data = cbind2(longitude.county,latitude.county)#
colnames(lat.long.data)=c("lon","lat")#
#Create spatial weight matrix#
distNeighbr = spdep::dnearneigh(lat.long.data, d1=0, d2=5)#
wtmat1 = spdep::nb2listw(distNeighbr, style='W')#
#
#Estimate the spatial fixed-effects model#
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("timeid", "panelid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
wtmat1
distNeighbr
class(wtmat1)
class(A)
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("timeid", "panelid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
#Estimate the spatial fixed-effects model#
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("panelid","timeid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
head(Produc)
usalw
as_tibble(Produc)
levels(Produc$state)
yield.normal
#Estimate the spatial fixed-effects model#
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("countyname","timeid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("county","timeid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("timeid", "county"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
class(Produc)
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("county", "timeid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
## fixed effects models#
mod <- spml(formula = fm, data = Produc, index = NULL,#
    listw = usalw, lag = TRUE, spatial.error = "b", model = "within",#
    effect = "individual", method = "eigen", na.action = na.fail,#
    quiet = TRUE, zero.policy = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
summary(mod)
usalw
lag.listw(usaw)
lag.listw(usalw)
head(Prod)
head(Produ)
head(Produc)
vcovDC(mod)
library(plm)
vcovDC(mod)
vcovHC(mod)
sandwich::vcovHC(mod)
plm::vcovHC(mod)
plm::vcovNW(mod)
bsktest(yield~trnd, data = yield.normal, listw =  wtmat1, test = "LM1")
pdat <- pdata.frame(yield.normal)
pdat
head(pdat)
pdat <- pdata.frame(yield.normal, c('county', 'timeid'))
head(pdat)
pdat <- pdata.frame(yield.normal, c('panelid', 'timeid'))
bsktest(yield~trnd, data = yield.normal, listw =  wtmat1, test = "LM1")
bsktest(yield~trnd, data = pdat, listw =  wtmat1, test = "LM1")
bsktest(yield~trnd, data = pdat, listw =  wtmat1, test = "LM2")
## only individual fixed effects:#
mod <- spml(formula = fm, data = Produc, index = NULL, listw = usalw,#
    model = "within", effect = "individual", method = "eigen",#
    na.action = na.fail, quiet = TRUE, zero.policy = NULL, #interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)
summary(mod)
eff <- effects(mod)
eff
mod <- spml(formula = fm, data = Produc, index = NULL, listw = usalw,#
    model = "within", effect = "time", method = "eigen",#
    na.action = na.fail, quiet = TRUE, zero.policy = NULL, #interval = NULL,#
    tol.solve = 1e-10, control = list(), legacy = FALSE)#
#
# time period fixed effects and the intercept can be recoverd as follows:#
effects(mod)
GM_error <- spgm(formula = fm, data = Produc, listw = usaww,#
   moments = "fullweights", model = "random", spatial.error = TRUE)
summary(GM_error)
GM_error <- spgm(formula = fm, data = Produc, lag = TRUE,#
    listw = usaww, model = "within", spatial.error = TRUE)
summary(GM_error)
?spgm
yield.normal <- as.data.frame(matrix(rnorm(2387*1, mean=1.92, sd=0.5), ncol=1))#
colnames(yield.normal) = "yield"#
yield.normal$panelid = with(yield.normal, seq(1:77))#
yield.normal$timeid = with(yield.normal, seq(1:31))#
yield.normal$county = with(yield.normal, as.factor(seq(1:77)))#
yield.normal$countyname = paste0("county",yield.normal$county)#
yield.normal$trnd = with(yield.normal, seq(1:31))#
#
yield.normal <- as_tibble(yield.normal)#
#
yield.normal <- yield.normal %>%#
    arrange(county, panelid, timeid)#
#
pdat <- pdata.frame(yield.normal, c('panelid', 'timeid'))#
#
#generate coordinates of the 77 Oklahoma counties#
latitude.county = sample(36.83013180:33.90212700, size = 77, replace = T)#
longitude.county = sample(-94.81059550:-102.62162110, size = 77, replace = T)#
lat.long.data = cbind2(longitude.county,latitude.county)#
colnames(lat.long.data)=c("lon","lat")#
#Create spatial weight matrix#
distNeighbr = spdep::dnearneigh(lat.long.data, d1=0, d2=5)#
wtmat1 = spdep::nb2listw(distNeighbr, style='W')#
#
#Estimate the spatial fixed-effects model#
spatial.FE.model = splm::spml(yield~trnd, data = yield.normal, index = c("county", "timeid"), listw = wtmat1,  model = "within", effect ="individual", method = "eigen")
## fiexed#
GM_error <- spgm(yield~trnd, data = yield.normal, index = c("county", "timeid"), listw = wtmat1,  model = "within", lag = TRUE, spatial.error = TRUE)
## fiexed#
GM_error <- spgm(yield~trnd, data = yield.normal, listw = wtmat1,  model = "within", lag = TRUE, spatial.error = TRUE)
traceback()
devtools::install_github("ropenscilabs/skimr")
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE, dev = "pdf", dpi = 300)#
options(knitr.table.format = "latex")#
#
rm(list = ls())#
set.seed(12345)#
library(knitr)#
library (dplyr)#
library (tidyr)#
library(forcats)#
library (network)#
library (sna)#
library(RColorBrewer)#
library(ggplot2)#
library(GGally)#
library(viridis)#
library(ggrepel)#
#
# for plotting#
library(ggmap)#
library(maptools)#
library(maps)#
library(mapproj)#
#
library(gridBase)#
library(grid)#
library(gridExtra)#
library(png)#
## for cleaning models#
library(car)#
library(broom)#
library(sandwich); library(lmtest)#
#
### ERGMS for Regime Shifts#
library(ergm.count)#
#
## for tables#
library(kableExtra)
load('~/Documents/Projects/Cascading Effects/170525_ergm_data.RData')#
## updated functions ###
## this can be deleted in the future#
#
## Updated ploting function#
plotnet <- function(net, ...){#
	plot.network(net, #mode='circle',#
			vertex.col = alpha(net %v% 'col', 0.7),#
			# label = network.vertex.names(net),#
			# label.cex= 1,#
			main = net %n% 'name', col.main = "gray44", cex.main = 1.2,#
			vertex.border = 0,#
			usecurve=T,#
			vertex.cex= 2, #2 + scale(net %v% 'fb'),#
			label.pos= 5,#
			edge.col= alpha(net %e% 'col' , 1),#
			edge.lwd =  rep(0.01, max(valid.eids(net))), #0.05 + net %e% 'fb',#
			edge.curve = 0.01,#
			displayisolates=T, pad = 0#
			)#
}#
#
plotnet2 <- function(net, ...){#
	plot.network(net, #mode='circle',#
			vertex.col = alpha(net %v% 'col', 0.7),#
			# label = network.vertex.names(net),#
			# label.cex= 1,#
			main = net %n% 'name', col.main = "gray44", cex.main = 1.2,#
			vertex.border = 0,#
			usecurve=T,#
			vertex.cex= 2 + scale(net %v% 'fb'),#
			label.pos= 5,#
			edge.col= alpha(net %e% 'col' , 1),#
			edge.lwd =  0.01 * net %e% 'fb',#
			edge.curve = 0.01,#
			displayisolates=T, pad = 0 # no need of pad for labels#
			)#
		}#
## A function to create the network, add polarity and cycles / feedbacks as edge attributes#
## J161105: Edge attributes are tricky to set because once the network is created the ordering of edges is lost and I cannot find the default order to set the right values. Reading the help of 'loading.attributes' I found that when declared as edgelist one can add attributes directly on the dataframe.#
rs.net <- function (dat, i){#
	# filter dataset#
	dat <- filter(dat, Regime.Shift == levels(dat$Regime.Shift)[i],#
	 Polarity == 1 | Polarity == -1)#
	#dat <- droplevels(dat)#
	# This ordering step is necessary to make sure polarity and other attributes are assigned correctly#
	# dat <- dat[order(dat$Tail, partial = dat$Head, decreasing = F),]#
	# tab <- table(dat$Tail, dat$Head, dat$Polarity) # tab is an array of tables#
		# dimnames(tab) [[3]] "-1"   "-0.5" "0.5"  "1"#
		# v <- as.matrix(tab[,,1]*-1) + as.matrix(tab[,,2])#
	# build network#
		rs.x <- network(select(dat, Tail, Head, Polarity, col), directed = T, ignore.eval=FALSE, matrix.type = 'edgelist')#
	# add polarity to edges: Outated, the way I create the network includes already the polarities by using ignore.eval = F. Edge color is also set on the network creation line.#
		# rs.x %e% 'polarity' <- dat$Polarity#
		# set.edge.value(rs.x, 'polarity', value = as.matrix(v))#
		# rs.x %e% 'col' <- ifelse(rs.x %e% "Polarity" == -1, 'red', 'blue')#
	# add cycles to nodes and edges.#
		fb.sum <- kcycle.census(rs.x, maxlen=network.size(rs.x), mode='digraph',	tabulate.by.vertex=T, cycle.comembership='sum')#
		# number of cycles per nodes#
		rs.x %v% 'fb' <-  diag(fb.sum$cycle.comemb)#
		# number of cycles per edge#
		rs.x %e% 'fb' <- as.sociomatrix(rs.x) * fb.sum$cycle.comemb#
		#J161106: Note that cycle.comemb is a matrix with comemberships, so two nodes that are not connected in the network can belong to the same cycles. That's why I multiply by the adjacency matrix, to isolate only the edges. cycle.comemb can be used later for discovery of inconvenient feedbacks.#
	## add vertex attributes#
		rs.x %v% 'col' <- ifelse(colSums(fb.sum$cycle.count)[-1] == 0, "#E41A1C","#8DA0CB") # "#FFD92F"#
		rs.x %n% 'name' <- levels(dat$Regime.Shift)[i]#
	return(rs.x)#
}
#x <- mode.1(bip1)[[2]] # x is the regime shifts one-mode network#
z <- mode.1(bip1)[[1]]#
# and#
# bip.edgelist <- bind_rows(bip.edgelist)#
# bipmat <- as.matrix(table(bip.edgelist))#
#
df_rs_type <- tibble(#
    tail = rsdb$name,#
    type = c("Aquatic", "Earth", "Aquatic", "Terrestrial", "Terrestrial", "Aquatic",#
             "Terrestrial", "Aquatic", "Aquatic", "Terrestrial", "Aquatic", "Earth",#
             "Aquatic", "Aquatic", "Land-water interface", "Aquatic",#
             "Aquatic", "Earth", "Land-water interface", "Aquatic","Land-water interface",#
             "Land-water interface", "Aquatic","Terrestrial","Terrestrial","Terrestrial",#
             "Earth","Land-water interface", "Terrestrial", "Earth")#
)#
#
g1 <- ggplot(#
    data = as.sociomatrix(x, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(x))) %>%#
        gather(key = head, value = paths,  1:30) %>% left_join(df_rs_type) %>%#
        mutate(tail = as.factor(tail) ) %>%#
        mutate(tail = forcats::fct_reorder(tail, paths, fun = sum, .desc = FALSE)),#
    aes(tail, paths, fill = type, color = type)) +#
    geom_boxplot(outlier.alpha = 0.5, alpha=0.5,#
                 outlier.size = 0.8) +#
    geom_point(#
        data = bip.edgelist %>% mutate(value = 1) %>%#
            group_by(rs) %>%#
            summarize(paths = sum(value)) %>% left_join(df_rs_type, by = c("rs" = "tail")) ,#
        aes(rs, paths), color = "black", size = 1.5, show.legend = FALSE#
    ) +#
    scale_fill_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    coord_flip() +  xlab("regime shifts") + ylab("number of drivers") + ggtitle("A") +#
    theme_minimal(base_size = 6) +#
    theme(legend.position = c(0.75, 0.2),#
          legend.background = element_rect(fill = "white", linetype = 0),#
          legend.text = element_text(size = 4), legend.title = element_text(size = 4))#
#
g2 <- ggplot(#
    data = as.sociomatrix(z, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(z))) %>%#
        gather(key = head, value = paths,  1:79) %>%#
        group_by(tail) %>% filter(mean(paths) >  1 ) %>% ungroup() %>%#
        mutate(tail = as.factor(tail)) %>%#
        mutate(tail = forcats::fct_reorder(tail, paths, fun = sum, .desc = FALSE)),#
    aes(tail, paths)) +#
    geom_boxplot(fill = alpha("grey", 0.7), color = "grey", outlier.alpha = 0.5,#
                 outlier.size = 0.8) +#
    # geom_point(#
    #     data = bip.edgelist %>% mutate(value = 1) %>%#
    #         group_by(drivers) %>%#
    #         summarize(paths = sum(value)),#
    #     aes(drivers, paths), color = "purple"#
    # ) +#
    coord_flip() +  xlab("most shared drivers\n [mean > 1]") + ylab("number of regime shifts") +  ggtitle("B") +#
    theme_minimal(base_size = 6)#
#
m1 <- ggplot(#
    data = as.sociomatrix(x, "paths") %>% as_tibble() %>% mutate(tail = rownames(as.sociomatrix(x))) %>%#
        gather(key = head, value = paths,  1:30)  %>%#
        mutate(tail = as.factor(tail), # %>% forcats::fct_rev(),#
               head = as.factor(head) %>% forcats::fct_rev()),#
    aes(tail, head)) +#
    geom_tile(aes(fill = paths)) + ylab("") + xlab("") + ggtitle("Drivers sharing") +#
    scale_fill_gradient(low = "gray84" ,high = "#0000FF80", na.value = "grey50",#
                         guide = guide_colorbar("shared drivers", barheight = 0.7)) +#
    theme_light (base_size = 6) +#
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),#
          legend.position = "bottom")#
#
## Heatmap with ggplot#
m2 <- ggplot(#
    data = out %>%#
         mutate(Tail = as.factor(Tail) %>% forcats::fct_rev(),#
               Head = as.factor(Head)), #%>% forcats::fct_rev()),#
    aes( Head, Tail)) +#
    geom_tile(aes(fill = weight)) + ggtitle("Domino effects") +#
    ylab("Independent regime shift") + xlab("Dependent regime shift") +#
    scale_fill_gradient(high = "red", low = "gray84", na.value = "grey50",#
                         guide = guide_colorbar("domino effects", barheight = 0.7))  +#
    theme_light(base_size = 6) +#
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),#
          legend.position = "bottom")#
#
df_domino <- out %>%#
        mutate(Tail = as.factor(Tail), Head = as.factor(Head)) %>%#
        filter(weight > 0) %>% pull(Tail) %>% fct_count() %>% rename(outdegree = n)#
#
df_domino <- left_join(df_domino,#
        out %>%#
        mutate(Tail = as.factor(Tail), Head = as.factor(Head)) %>%#
        filter(weight > 0) %>% pull(Head) %>% fct_count() %>% rename(indegree = n)#
)#
#
df_domino <- left_join(df_domino,#
    out %>% group_by(Tail) %>%#
        summarize(out_avg = mean(weight), out_max = max(weight)) %>%#
        rename(f = Tail)#
)#
#
df_domino <- left_join(df_domino,#
    out %>% group_by(Head) %>%#
        summarize(in_avg = mean(weight), in_max = max(weight)) %>%#
        rename(f = Head)#
)#
#
df_poly <- data_frame(#
    id = rep(factor(c("1", "2")), each = 3),#
    x = c(0,0,10, 0,25,25),#
    y = c(0,25,25, 0,10,0),#
    value = c(rep(alpha("orange", 0.4),3), rep(alpha("green", 0.4),3))#
)#
#
g3 <- ggplot(#
    data = df_domino %>% left_join (df_rs_type, by = c("f" = "tail")) ,#
    aes(y = outdegree, x = indegree)) +#
    geom_point( aes(color = type), size = 1.5, show.legend = TRUE) +#
    #geom_errorbar(aes(ymin = in_avg, ymax = in_max, color = type)) +#
    #geom_errorbarh(aes(xmin = out_avg, xmax = out_max, color = type)) +#
    geom_text_repel(data = df_domino %>% filter(out_max > 3 | in_max > 3),#
                    aes(label = f), size = 1.5) +#
    geom_polygon(data = df_poly,  mapping = aes(x, y, group = id, fill = value), show.legend = FALSE, position = "identity", stat = "identity", inherit.aes = FALSE) +#
    scale_fill_manual(values = c(alpha("orange", 0.2),alpha("green", 0.2))) +#
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    ggtitle("A") + coord_equal() +#
    labs(x = "indegree\n [dependent regime shifts]", y = "outdegree\n [independent regime shifts]") +#
    theme_minimal(base_size = 6) +#
    theme(legend.position = c(0.8, 0.8),#
          legend.background = element_rect(fill = "white", linetype = 0),#
          legend.text = element_text(size = 5), legend.title = element_text(size =5)#
          )#
g4 <- ggplot(#
    out %>% filter(weight > 0) %>%#
        pull(driv2feed) %>% stringr::str_split(pattern = ", ") %>%#
        unlist() %>% as_tibble() %>% rename(driver = value) %>%#
        group_by(driver) %>% summarize(n = n()) %>% ungroup() %>%#
        mutate(driver = as_factor(driver)) %>%#
        mutate(driver = fct_reorder(driver, n, .desc = FALSE)) %>%#
        filter(n > 1),#
    aes(driver, n)) +#
    geom_bar(stat = "identity") + coord_flip() + ylab("number of domino effects") + xlab("key variables")+#
    ggtitle('B') + theme_minimal(base_size = 6)#
## Heatmap with ggplot#
m3 <- ggplot(#
    data = df_inc %>%#
         mutate(Tail = as.factor(Tail) %>% forcats::fct_rev(),#
               Head = as.factor(Head)), #%>% forcats::fct_rev()),#
    aes( Head, Tail)) +#
    geom_tile(aes(fill = log(inc)))  + ggtitle("Hidden feedbacks") +#
    ylab("") + xlab("") +#
    scale_fill_gradient(low = "#FFA50080", high = "#0000FF80", na.value = "grey50",#
                        guide = guide_colorbar("hidden feedbacks [log]", barheight = 0.7)) +#
    theme_minimal(base_size = 6) +#
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5 ),#
          legend.position = "bottom")  +#
    inset(#
        grob = ggplotGrob(#
            ggplot(data = df_inc, aes(inc)) +#
                geom_histogram() + xlab('Hidden feedbacks') +#
                theme_light(base_size = 6) ) , xmin = 0, xmax =15 , ymin = 0, ymax = 15)#
#
## I need to make the matrix symmetric so it does count the degrees correctly.#
df_inc2 <- data.frame(inc = inc, Head = levels(dat$Regime.Shift)[key[1,]], Tail = levels(dat$Regime.Shift)[key[2,]])#
#
df_inc3 <- bind_rows(df_inc, df_inc2)#
#
g5 <- ggplot(#
    data = df_inc3 %>%#
        mutate(Tail = as.factor(Tail), Head = as.factor(Head)) %>%#
        left_join (df_rs_type, by = c("Tail" = "tail")) %>%#
        mutate(Tail = fct_reorder(Tail, inc, fun = mean, .desc = FALSE )) %>% filter(inc > 0)  ,#
    aes(Tail, inc, color = type, fill = type)) +#
    geom_boxplot( outlier.alpha = 0.5, alpha = 0.5,#
                 outlier.size = 0.8, show.legend = TRUE) +#
    # geom_point(#
    #     data = df_inc3 %>%#
    #         group_by(Tail) %>%#
    #         summarize(outdegree = sum(inc > 0)),#
    #     aes(Tail, outdegree), color = "orange", size = 1.5, shape = 12#
    # ) +#
    scale_y_log10()+#
    scale_fill_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    coord_flip() +#
    xlab("regime shifts") + ylab("hidden feedbacks") + ggtitle("A") +#
    theme_minimal(base_size = 6)+#
    theme(legend.position = c(0.85, 0.2),#
          legend.background = element_rect(fill = "white", linetype = 0),#
          legend.text = element_text(size = 4), legend.title = element_text(size = 4)#
          )#
#
z <- bind_rows(out_dat)#
#
z <- gather(z,`Inconvenient`,`Expected`, key = Feedbacks, value = count)#
#
z$Feedbacks <- factor(z$Feedbacks)#
levels(z$Feedbacks)[2] <- "Hidden"#
#
## J171213: Alternative to g6#
 brain <- network(select(dat, Tail, Head, Polarity, col), directed = T, ignore.eval=FALSE, matrix.type = 'edgelist')#
 df_brain <- tibble(#
     variable = network.vertex.names(brain),#
     betweenness = betweenness(brain, cmode = "directed", rescale = TRUE),#
     indeg = degree(brain, cmode ="indegree"),#
     outdeg = degree(brain, cmode = "outdegree"),#
     closeness = closeness(brain, cmode = "suminvdir", rescale = TRUE))#
#
g6 <- ggplot(data = df_brain, aes(betweenness, closeness)) +#
    geom_point(aes(color = indeg, fill = outdeg),#
               shape = 21, size = 1, stroke = 1, alpha = 0.9) +#
    geom_text_repel(data = filter(df_brain, betweenness > 0.015 | closeness > 0.0052),  #
                    aes(label = variable), size = 1.5) +#
    scale_color_gradient(low = "#6495ED", high = "#00008B", guide = "colorbar", name = " Indegree") +#
    scale_fill_gradient(low = "#FFD700", high = "#8B0000", guide = "colorbar", name =  "Outdegree") +#
    theme_minimal(base_size = 6) + ggtitle("B") +#
    theme(legend.position = "right", legend.direction = "vertical",#
          legend.text = element_text(size = 4), legend.title = element_text(size = 4)) #+#
    # inset(#
    #     grob = ggplotGrob(#
    #         ggnet2(brain, size=1, arrow.size = 1.5, arrow.gap = 0.01, edge.alpha = 0.5,#
    #                edge.size = 0.1)#
    #     ), xmin = 0.015, xmax =0.04 , ymin = 0, ymax = 0.004#
    # )#
### Insert figures with models here.#
## Models for sharing drivers#
df1 <- tidy(fit.w1); df1$model <- 'sharing drivers'#
df1$term <- c("Non-zero",'Sum', "Landuse","Ecosystem type", "Ecosystem processes", "Provisioning services","Regulating services", "Cultural services", "Impacts on human wellbeing", "Spatial scale: national", "Spatial scale: subcontinental", "Temporal scale: month - year", "Temporal scale: week - month", "Temporal scale: year - decade", "Match spatial scale", "Match temporal scale", "Reversibility", "Evidence type")#
## model for domino effects#
df2 <- tidy(fit.w2); df2$model <- 'domino effects'#
df2$term <- c("Non-zero",'Sum', "Landuse","Ecosystem type", "Ecosystem processes", "Provisioning services","Regulating services", "Cultural services", "Impacts on human wellbeing",#
               #"Indegree - Spatial scale: national", "Indegree - Spatial scale: subcontinental", "Indegree - Temporal scale: month - year", "Indegree - Temporal scale: week - month", "Indegree - Temporal scale: year - decade",#
               #"Outdegree - Spatial scale: national", "Outdegree - Spatial scale: subcontinental", "Outdegree - Temporal scale: month - year", "Outdegree - Temporal scale: week - month", "Outdegree - Temporal scale: year - decade",#
              #"Match spatial scale: local","Match spatial scale: national","Match spatial scale: sub-continental", "Match temporal scale",#
              "Spatial scale", "Temporal scale",#
              "Reversibility", "Evidence type")#
## model for hidden feedbacks#
df3 <- tidy(fit.w3a); df3$model <- 'hidden feedbacks'#
df3$term <- c("Non-zero",'Sum', "Landuse","Ecosystem type", "Ecosystem processes", "Provisioning services","Regulating services", "Cultural services", "Impacts on human wellbeing",#
              "Spatial scale: national", "Spatial scale: subcontinental", "Temporal scale: month - year", "Temporal scale: week - month", "Temporal scale: year - decade", "Match spatial scale", "Match temporal scale",#
              "Reversibility", "Evidence type")#
#
df <- full_join(df1, df2) %>% full_join(df3) %>% as_tibble()#
# df <-df %>% mutate(estimate = exp(estimate), std.error = exp(std.error)) ## In case you want to read probabilities directly instead of log odds#
df <- mutate(df, conf.hi = estimate + std.error, conf.low = estimate - std.error)#
df$P <- ifelse(df$p.value <= 0.05, "< 0.05", "> 0.05")#
df$term <- as.factor(df$term)#
#
# ## change names of places and reorder levels#
df$term <- factor(df$term, levels(df$term)[c(9,16,6,3,2,10,11,1,5, 13,17,14,15,19,18,20,7,8, 12,4)] )#
# df$term <- factor(df$term, levels(df$term)[c(17, 28, 11,3,2,23,24,1,5, 26,27, 30,29,31, 6:10,18:22,  12:16, 25,4)] )#
df$term <- factor(df$term, rev(levels(df$term)))#
#
df$model <- as.factor(df$model)#
df$model <- factor(df$model, levels(df$model)[c(3,1,2)])#
#
## plot results#
p <- ggplot(df, aes(estimate, term))+#
    geom_point(aes(shape = factor(P)), size = 2, show.legend = T) +#
    scale_shape_manual(name = "p value", values = c(19,1)) +#
    geom_errorbarh(aes(xmax = conf.hi, xmin = conf.low, height = .25),#
                   show.legend = T) + #ggtitle("g)") +#
    geom_vline(xintercept = 0, color = 'grey', show.legend = F, linetype = 2)  +#
    facet_wrap(~ model, scales = "free_x") + theme_light(base_size = 6) +#
    theme(legend.position = "right", plot.margin = margin(t=2,r=5,b=2,l=5,"pt"))#
## Combine the figure old way#
# gg <- list (g1,g2,g3,g4,g5,g6, p)#
# source('~/Dropbox/Code/multiplot.R')#
# layout <- matrix(c(1:6,7,7,7), ncol = 3, nrow = 3, byrow = T)#
# multiplot(plotlist = gg, layout = layout)#
## New way:#
gg <- list (g1,g2)#
source('~/Dropbox/Code/multiplot.R')#
layout <- matrix(c(1,2), ncol = 2, nrow = 1, byrow = T)#
multiplot(plotlist = gg, layout = layout)
g3
df_poly <- data_frame(#
    id = rep(factor(c("1", "2")), each = 3),#
    x = c(0,0,10, 0,25,25),#
    y = c(0,25,25, 0,10,0),#
    value = as.factor(c(rep(alpha("orange", 0.4),3), rep(alpha("green", 0.4),3)))#
)
g3 <- ggplot(#
    data = df_domino %>% left_join (df_rs_type, by = c("f" = "tail")) ,#
    aes(y = outdegree, x = indegree)) +#
    geom_point( aes(color = type), size = 1.5, show.legend = TRUE) +#
    #geom_errorbar(aes(ymin = in_avg, ymax = in_max, color = type)) +#
    #geom_errorbarh(aes(xmin = out_avg, xmax = out_max, color = type)) +#
    geom_text_repel(data = df_domino %>% filter(out_max > 3 | in_max > 3),#
                    aes(label = f), size = 1.5) +#
    geom_polygon(data = df_poly,  mapping = aes(x, y, group = id, fill = value), show.legend = FALSE, position = "identity", stat = "identity", inherit.aes = FALSE) +#
    scale_fill_manual(values = c(alpha("orange", 0.2),alpha("green", 0.2))) +#
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    ggtitle("A") + coord_equal() +#
    labs(x = "indegree\n [dependent regime shifts]", y = "outdegree\n [independent regime shifts]") +#
    theme_minimal(base_size = 6) +#
    theme(legend.position = c(0.8, 0.8),#
          legend.background = element_rect(fill = "white", linetype = 0),#
          legend.text = element_text(size = 5), legend.title = element_text(size =5)#
          )
g3
ggplot(#
    data = df_domino %>% left_join (df_rs_type, by = c("f" = "tail")) ,#
    aes(y = outdegree, x = indegree)) +#
    geom_point( aes(color = type), size = 1.5, show.legend = TRUE) +#
    #geom_errorbar(aes(ymin = in_avg, ymax = in_max, color = type)) +#
    #geom_errorbarh(aes(xmin = out_avg, xmax = out_max, color = type)) +#
    geom_text_repel(data = df_domino %>% filter(out_max > 3 | in_max > 3),#
                    aes(label = f), size = 1.5) +#
    geom_polygon(data = df_poly,  mapping = aes(x, y, group = id, fill = value), show.legend = FALSE, position = "identity", stat = "identity", inherit.aes = FALSE) +#
    scale_fill_manual(guide = NULL, values = c(alpha("orange", 0.2),alpha("green", 0.2))) +#
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    ggtitle("A") + coord_equal() +#
    labs(x = "indegree\n [dependent regime shifts]", y = "outdegree\n [independent regime shifts]") +#
    theme_minimal(base_size = 6) +#
    theme(legend.position = c(0.8, 0.8),#
          legend.background = element_rect(fill = "white", linetype = 0),#
          legend.text = element_text(size = 5), legend.title = element_text(size =5)#
          )
ggplot(#
    data = df_domino %>% left_join (df_rs_type, by = c("f" = "tail")) ,#
    aes(y = outdegree, x = indegree)) +#
    geom_point( aes(color = type), size = 1.5, show.legend = TRUE) +#
    #geom_errorbar(aes(ymin = in_avg, ymax = in_max, color = type)) +#
    #geom_errorbarh(aes(xmin = out_avg, xmax = out_max, color = type)) +#
    geom_text_repel(data = df_domino %>% filter(out_max > 3 | in_max > 3),#
                    aes(label = f), size = 1.5) +#
    geom_polygon(data = df_poly,  mapping = aes(x, y, group = id, fill = value), show.legend = FALSE, position = "identity", stat = "identity", inherit.aes = FALSE) +#
    scale_fill_manual(guide = "none", values = c(alpha("orange", 0.2),alpha("green", 0.2))) +#
    scale_color_manual("Ecosystem type",values = c("blue", "purple", "red","orange")) +#
    ggtitle("A") + coord_equal() +#
    labs(x = "indegree\n [dependent regime shifts]", y = "outdegree\n [independent regime shifts]") +#
    theme_minimal(base_size = 6) +#
    theme(legend.position = c(0.8, 0.8),#
          legend.background = element_rect(fill = "white", linetype = 0),#
          legend.text = element_text(size = 5), legend.title = element_text(size =5)#
          )
library(tidyverse)
?read_xls
library(readxl)
dat <- read_xls("~/Documents/Projects/Students & Interns/Aracely/Budget distribucioÌn normal.xlsx")
dat <- read_xlsx("~/Documents/Projects/Students & Interns/Aracely/Budget distribucioÌn normal.xlsx")
dat
g <- ggplot(dat, aes(COP)) + geom_density()
g
g <- ggplot(dat, aes(log1p(COP))) + geom_density()
g
range(dat$COP)
pull(dat$COP)
is.na(dat$COP)
dat
dat <- filter(dat, !is.na(COP))
dat
g <- ggplot(dat, aes(log1p(COP))) + geom_density()
g
g <- ggplot(dat, aes(log(COP))) + geom_density()
g
summary((dat$COP))
g <- ggplot(dat, aes(COP)) + geom_density()
g
g <- ggplot(dat, aes(log(COP))) + geom_density()
g
summary(log(dat$COP))
rm(list = ls())
set.seed(12345)#
# this file combines code from the 161027 draft and the simplified version of the analysis#
#
## load libraries#
library(tidyverse)#
library(forcats)#
library  ('gdata')#
library (readxl)#
# library (corrgram)#
# library(GGally)#
library(broom)#
#
# load libraries for mapping#
library(maptools)#
library(rgeos)#
library(RColorBrewer)#
library(ggmap)#
library(grid)#
library(gridExtra)#
#
# load libraries for clustering#
library (vegan)#
# library(rgl)#
# library(cluster)#
library(NbClust)#
library(clValid)#
# library(MASS)#
library(kohonen)#
library(FactoMineR)#
library(factoextra)
## Read data#
load("180129_Volta.RData")#
df <- mutate(df, id = TAI_ID1)#
df$clus <- clusters$Hierarchical
setwd('~/Documents/Projects/TAI/scripts/TAI-Volta')
## Read data#
load("180129_Volta.RData")#
df <- mutate(df, id = TAI_ID1)#
df$clus <- clusters$Hierarchical
## correct the intercept issue.#
fit <- list()#
fit <- map2(select(df_lm, starts_with("m2_")), select(df_lm, starts_with("a_")), ~ lm(.x ~ .y + Aridity + Mean_temp + Wet_season + Soil_water + Slope75 + Farmers + Literacy + Market_access + Dams, data = df_lm))#
#
stargazer::stargazer(#
    fit, align = F, header = F, type = 'latex', digits = 2,#
    float = T, no.space = F, single.row = F, font.size = "small",#
    float.env = "sidewaystable", #style = "aer",#
    dep.var.labels = "crop", dep.var.labels.include = T,#
    column.labels = str_sub(names(fit), start = 4L, end = -1L),#
    covariate.labels = c("Cropped area", "Aridity", "Mean temperature", "Wet season",#
                         "Soil water", "Slope", "Farmers", "Literacy", "Market access",#
                         "Dams density"),#
    title = "Regression on mean kilocalorie production per crop",#
    notes = "Units of are kilocalorie per capita for each administrative unit", notes.append = TRUE#
)
## correct the intercept issue:#
fit_sd <- list()#
fit_sd <-  map2(#
    select(df_lm, starts_with("sd_"), -sd_kcals),#
    select(df_lm, starts_with("a_")), ~ lm(.x ~ .y + Aridity + Mean_temp + Wet_season + Soil_water + Slope75 + Farmers + Literacy + Market_access + Dams, data = df_lm))
are on log-scale already.#
fit2 <- list()#
fit2 <- map2(select(df_lm, starts_with("m_")), select(df_lm, starts_with("a_")), ~ lm(.x ~ .y + Aridity + Mean_temp + Wet_season + Soil_water + Slope75 + Farmers + Literacy + Market_access + Dams, data = df_lm))
df_lm <- df_lm %>%#
  mutate(sd_cowpea = log1p(sd_cowpea),#
         sd_maize = log1p(sd_maize),#
         sd_millet = log1p(sd_millet),#
         sd_rice = log1p(sd_rice),#
         sd_sorghum = log1p(sd_sorghum),#
         sd_soy = log1p(sd_soy), #
         sd_yam = log1p(sd_yam))#
#
fit_sd2 <- list()#
fit_sd2 <-  map2(#
    select(df_lm, starts_with("sd_"), -sd_kcals),#
    select(df_lm, starts_with("a_")), ~ lm(.x ~ .y + Aridity + Mean_temp + Wet_season + Soil_water + Slope75 + Farmers + Literacy + Market_access + Dams, data = df_lm))
z <- names(select(df_lm, starts_with("m2_")))#
#
df_kc <- fit %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})#
#
for(i in seq_along(z)) {df_kc[[i]]$response <- z[[i]] }#
#
df_kc <- df_kc %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)#
z <- names(select(df_lm, starts_with("sd_"), -sd_kcals))#
#
df_sd <- fit_sd %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})#
#
for(i in seq_along(z)) {df_sd[[i]]$response <- z[[i]] }#
#
df_sd <- df_sd %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
quartz(width = 3.5, height = 4, pointsize = 6)
bind_rows(#
    bind_rows(df_kc),#
    bind_rows(df_sd)#
) %>% mutate(term = as_factor(term) %>% fct_rev()) %>%#
filter(term != 'area') %>%#
    ggplot(aes(estimate, term)) +#
        geom_vline(xintercept = 0, color = "grey84", linetype = 2) +#
        geom_point(aes(shape = ifelse(#
            p.value < 0.05, "< 0.05" ,#
                ifelse(p.value < 0.1, "< 0.1", "> 0.1")#
            )), size = 1, show.legend = TRUE) +#
        scale_shape_manual(name = "p value", values = c(19,7,1)) +#
        geom_errorbarh(aes(xmin = estimate - std.error , xmax = estimate + std.error, height = .25), size = 0.25)+#
        #geom_text(data = df_r2, x=-Inf, y=Inf, hjust = 0, vjust = 45, size = 3, aes(label = paste("italic(R) ^ 2 == ", round(r_squared,2))), parse = T) +#
        theme_light(base_size = 6)+ theme(legend.position = "right")+#
        facet_grid(response ~ type, scales = "free")
## Read data#
load("180129_Volta.RData")#
df <- mutate(df, id = TAI_ID1)#
df$clus <- clusters$Hierarchical
fit2 <- list()#
fit2 <- map2(select(df_lm, starts_with("m_")), select(df_lm, starts_with("a_")), ~ lm(.x ~ log1p(.y) + Aridity + Mean_temp + Wet_season + Soil_water + Slope75 + Farmers + Literacy + Market_access + Dams, data = df_lm))
df_lm <- df_lm %>%#
  mutate(sd_cowpea = log1p(sd_cowpea),#
         sd_maize = log1p(sd_maize),#
         sd_millet = log1p(sd_millet),#
         sd_rice = log1p(sd_rice),#
         sd_sorghum = log1p(sd_sorghum),#
         sd_soy = log1p(sd_soy), #
         sd_yam = log1p(sd_yam))#
#
fit_sd2 <- list()#
fit_sd2 <-  map2(#
    select(df_lm, starts_with("sd_"), -sd_kcals),#
    select(df_lm, starts_with("a_")), ~ lm(.x ~ log1p(.y) + Aridity + Mean_temp + Wet_season + Soil_water + Slope75 + Farmers + Literacy + Market_access + Dams, data = df_lm))
z <- names(select(df_lm, starts_with("m2_")))#
#
df_kc <- fit %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})#
#
for(i in seq_along(z)) {df_kc[[i]]$response <- z[[i]] }#
#
df_kc <- df_kc %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)#
z <- names(select(df_lm, starts_with("sd_"), -sd_kcals))#
#
df_sd <- fit_sd %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})#
#
for(i in seq_along(z)) {df_sd[[i]]$response <- z[[i]] }#
#
df_sd <- df_sd %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
quartz(width = 3.5, height = 4, pointsize = 6)#
#
bind_rows(#
    bind_rows(df_kc),#
    bind_rows(df_sd)#
) %>% mutate(term = as_factor(term) %>% fct_rev()) %>%#
filter(term != 'area') %>%#
    ggplot(aes(estimate, term)) +#
        geom_vline(xintercept = 0, color = "grey84", linetype = 2) +#
        geom_point(aes(shape = ifelse(#
            p.value < 0.05, "< 0.05" ,#
                ifelse(p.value < 0.1, "< 0.1", "> 0.1")#
            )), size = 1, show.legend = TRUE) +#
        scale_shape_manual(name = "p value", values = c(19,7,1)) +#
        geom_errorbarh(aes(xmin = estimate - std.error , xmax = estimate + std.error, height = .25), size = 0.25)+#
        #geom_text(data = df_r2, x=-Inf, y=Inf, hjust = 0, vjust = 45, size = 3, aes(label = paste("italic(R) ^ 2 == ", round(r_squared,2))), parse = T) +#
        theme_light(base_size = 6)+ theme(legend.position = "right")+#
        facet_grid(response ~ type, scales = "free")
df_kc
dfOlm
df_lm
z <- names(select(df_lm, starts_with("m2_")))
z
fit %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})
fit2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})
fit2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[2] <- "log area";return(x)})
df_kc <- fit2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[2] <- "log area";return(x)})#
#
for(i in seq_along(z)) {df_kc[[i]]$response <- z[[i]] }
df_kc
df_kc <- df_kc %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
df_kc
df_kc$type <- "log kcals"
df_kc
df_kc <- fit2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[2] <- "log area";return(x)})#
#
for(i in seq_along(z)) {df_kc[[i]]$response <- z[[i]] }#
#
df_kc <- df_kc %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
df_kc <- df_kc %>% mutate(type = "log kcals")
df_kc <- fit2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[2] <- "log area";return(x)})#
#
for(i in seq_along(z)) {df_kc[[i]]$response <- z[[i]] }#
#
df_kc <- df_kc %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
df_kc
class(df_kc)
df_kc <- df_kc %>% purrr::map(#
    function(x) mutate(x, type = "log kcals")#
)
df_kc
df_kc <- df_kc %>% purrr::map(#
    function(x) mutate(x, type = "log kcal")#
)
z <- names(select(df_lm, starts_with("sd_"), -sd_kcals))#
#
df_sd <- fit_sd %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[1] <- "area";return(x)})#
#
for(i in seq_along(z)) {df_sd[[i]]$response <- z[[i]] }#
#
df_sd <- df_sd %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
bind_rows(#
    bind_rows(df_kc),#
    bind_rows(df_sd)#
) %>% mutate(term = as_factor(term) %>% fct_rev()) %>%#
# filter(term != 'area') %>%#
    ggplot(aes(estimate, term)) +#
        geom_vline(xintercept = 0, color = "grey84", linetype = 2) +#
        geom_point(aes(shape = ifelse(#
            p.value < 0.05, "< 0.05" ,#
                ifelse(p.value < 0.1, "< 0.1", "> 0.1")#
            )), size = 1, show.legend = TRUE) +#
        scale_shape_manual(name = "p value", values = c(19,7,1)) +#
        geom_errorbarh(aes(xmin = estimate - std.error , xmax = estimate + std.error, height = .25), size = 0.25)+#
        #geom_text(data = df_r2, x=-Inf, y=Inf, hjust = 0, vjust = 45, size = 3, aes(label = paste("italic(R) ^ 2 == ", round(r_squared,2))), parse = T) +#
        theme_light(base_size = 6)+ theme(legend.position = "right")+#
        facet_grid(response ~ type, scales = "free")
df_kc <- fit2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[2] <- "log area";return(x)})#
#
for(i in seq_along(z)) {df_kc[[i]]$response <- z[[i]] }#
#
df_kc <- df_kc %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)#
#
df_kc <- df_kc %>% purrr::map(#
    function(x) mutate(x, type = "log kcal")#
)
z <- names(select(df_lm, starts_with("sd_"), -sd_kcals))
fit_sd2 %>% purrr::map(tidy)
df_sd <- fit_sd2 %>% purrr::map(tidy) %>%#
    purrr::map(function(x){x$term[2] <- "log area";return(x)})
for(i in seq_along(z)) {df_sd[[i]]$response <- z[[i]] }#
#
df_sd <- df_sd %>% purrr::map(#
    function(x) separate(x, col = response, into = c("type", "response"))#
)
bind_rows(#
    bind_rows(df_kc),#
    bind_rows(df_sd)#
) %>% mutate(term = as_factor(term) %>% fct_rev()) %>%#
# filter(term != 'area') %>%#
    ggplot(aes(estimate, term)) +#
        geom_vline(xintercept = 0, color = "grey84", linetype = 2) +#
        geom_point(aes(shape = ifelse(#
            p.value < 0.05, "< 0.05" ,#
                ifelse(p.value < 0.1, "< 0.1", "> 0.1")#
            )), size = 1, show.legend = TRUE) +#
        scale_shape_manual(name = "p value", values = c(19,7,1)) +#
        geom_errorbarh(aes(xmin = estimate - std.error , xmax = estimate + std.error, height = .25), size = 0.25)+#
        #geom_text(data = df_r2, x=-Inf, y=Inf, hjust = 0, vjust = 45, size = 3, aes(label = paste("italic(R) ^ 2 == ", round(r_squared,2))), parse = T) +#
        theme_light(base_size = 6)+ theme(legend.position = "right")+#
        facet_grid(response ~ type, scales = "free")
bind_rows(#
    bind_rows(df_kc),#
    bind_rows(df_sd)#
) %>% mutate(term = as_factor(term) %>% fct_rev()) %>%#
 filter(term != 'log area') %>%#
    ggplot(aes(estimate, term)) +#
        geom_vline(xintercept = 0, color = "grey84", linetype = 2) +#
        geom_point(aes(shape = ifelse(#
            p.value < 0.05, "< 0.05" ,#
                ifelse(p.value < 0.1, "< 0.1", "> 0.1")#
            )), size = 1, show.legend = TRUE) +#
        scale_shape_manual(name = "p value", values = c(19,7,1)) +#
        geom_errorbarh(aes(xmin = estimate - std.error , xmax = estimate + std.error, height = .25), size = 0.25)+#
        #geom_text(data = df_r2, x=-Inf, y=Inf, hjust = 0, vjust = 45, size = 3, aes(label = paste("italic(R) ^ 2 == ", round(r_squared,2))), parse = T) +#
        theme_light(base_size = 6)+ theme(legend.position = "right")+#
        facet_grid(response ~ type, scales = "free")
quartz.save("figures/fig_5a.pdf", type = "pdf", width = 3.5, height = 4, dpi = 500, pointsize = 6)
quartz(width = 3.5, height = 4, pointsize = 6)#
#
bind_rows(#
    bind_rows(df_kc),#
    bind_rows(df_sd)#
) %>% mutate(term = as_factor(term) %>% fct_rev()) %>%#
 filter(term != 'log area') %>%#
    ggplot(aes(estimate, term)) +#
        geom_vline(xintercept = 0, color = "grey84", linetype = 2) +#
        geom_point(aes(shape = ifelse(#
            p.value < 0.05, "< 0.05" ,#
                ifelse(p.value < 0.1, "< 0.1", "> 0.1")#
            )), size = 1, show.legend = TRUE) +#
        scale_shape_manual(name = "p value", values = c(19,7,1)) +#
        geom_errorbarh(aes(xmin = estimate - std.error , xmax = estimate + std.error, height = .25), size = 0.25)+#
        #geom_text(data = df_r2, x=-Inf, y=Inf, hjust = 0, vjust = 45, size = 3, aes(label = paste("italic(R) ^ 2 == ", round(r_squared,2))), parse = T) +#
        theme_light(base_size = 6)+ theme(legend.position = "right")+#
        facet_grid(response ~ type, scales = "free")
quartz.save("figures/fig_5a.png", type = "png", width = 3.5, height = 4, dpi = 500, pointsize = 6)
